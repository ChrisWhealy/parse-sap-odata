pub mod property_type;

use check_keyword::CheckKeyword;
use convert_case::Case;
use serde::{Deserialize, Serialize};

use crate::ms_annotations::MSAnnotationsProperty;
use crate::sap_annotations::SAPAnnotations;
use crate::xml::default_true;

#[derive(Debug, Serialize, Deserialize)]
#[serde(rename_all = "PascalCase")]
pub struct Property {
    pub name: String,

    #[serde(rename = "Type")]
    pub edm_type: String,

    #[serde(default = "default_true")]
    pub nullable: bool,

    pub max_length: Option<String>,

    pub precision: Option<String>,
    pub scale: Option<String>,
    pub concurrency_mode: Option<String>,

    // Microsoft Annotations
    #[serde(flatten)]
    pub ms_annotations: MSAnnotationsProperty,

    // SAP Annotations
    #[serde(flatten)]
    pub sap_annotations: SAPAnnotations,
}

/// ********************************************************************************************************************
/// The `Cargo.toml` of the application consuming the code generated by this tool must declare at least the following
/// dependencies:
///
/// ```toml
/// [dependencies]
/// rust_decimal = "1.29"
/// uuid = "1.3"
/// ```
///
/// Edm.Decimal --> rust_decimal::Decimal
/// Edm.Guid    --> uuid::Uuid
/// ********************************************************************************************************************
impl Property {
    fn maybe_optional(rust_type: &str, is_optional: bool) -> String {
        if is_optional {
            format!("Option<{}>", rust_type)
        } else {
            rust_type.to_string()
        }
    }

    fn to_rust_safe_name(&self) -> String {
        CheckKeyword::into_safe(convert_case::Casing::to_case(&self.name, Case::Snake))
    }

    fn to_rust_type(&self, namespace: &str) -> String {
        match self.edm_type.as_ref() {
            "Edm.Binary" => Property::maybe_optional("Vec<u8>", self.nullable),
            "Edm.Boolean" => Property::maybe_optional("bool", self.nullable),
            "Edm.Byte" => "u8".to_string(),
            "Edm.DateTime" => Property::maybe_optional("NaiveDateTime", self.nullable),
            // TODO I suspect that this may not be the correct Rust datatype for Edm.DateTimeOffset...
            "Edm.DateTimeOffset" => Property::maybe_optional("NaiveDateTime", self.nullable),
            "Edm.Decimal" => "Decimal".to_string(),
            "Edm.Double" => "f64".to_string(),
            "Edm.Single" => "f32".to_string(),
            "Edm.Guid" => "uuid".to_string(),
            "Edm.SByte" => Property::maybe_optional("i8", self.nullable),
            "Edm.Int16" => Property::maybe_optional("i16", self.nullable),
            "Edm.Int32" => Property::maybe_optional("i32", self.nullable),
            "Edm.Int64" => Property::maybe_optional("i64", self.nullable),
            "Edm.String" => Property::maybe_optional("String", self.nullable),
            "Edm.Time" => Property::maybe_optional("std::time::SystemTime", self.nullable),

            // Assume that if the type is not a known EDM type, then it must be a service-specific complex type, in
            // which case, remove the namespace prefix
            type_name => (match type_name.strip_prefix(&format!("{}.", namespace)) {
                Some(suffix) => suffix,
                None => type_name,
            })
            .to_string(),
        }
    }

    pub fn to_rust(&self, namespace: &str) -> Vec<u8> {
        format!(
            "\npub {}: {},",
            self.to_rust_safe_name(),
            self.to_rust_type(namespace)
        )
        .as_bytes()
        .to_vec()
    }
}

#[derive(Debug, Serialize, Deserialize)]
#[serde(rename_all = "PascalCase")]
pub struct PropertyRef {
    pub name: String,
}

mod tests {
    use check_keyword::CheckKeyword;

    #[test]
    fn should_convert_unsafe_property_name() {
        let kw = "type";

        assert!(kw.is_keyword());
        assert_eq!(kw.into_safe(), "r#type");
    }

    #[test]
    fn should_not_convert_safe_property_name() {
        let kw = "wibble";

        assert!(!kw.is_keyword());
        assert_eq!(kw.into_safe(), "wibble");
    }
}
