// pub mod property_type;

use check_keyword::CheckKeyword;
use convert_case::Case;
use serde::{Deserialize, Serialize};

use crate::ms_annotations::MSAnnotationsProperty;
use crate::sap_annotations::SAPAnnotations;
use crate::xml::default_true;

#[derive(Debug, Serialize, Deserialize)]
#[serde(rename_all = "PascalCase")]
pub struct Property {
    pub name: String,

    #[serde(rename = "Type")]
    pub edm_type: String,

    #[serde(default = "default_true")]
    pub nullable: bool,

    pub max_length: Option<String>,

    pub precision: Option<String>,
    pub scale: Option<String>,
    pub concurrency_mode: Option<String>,

    // Microsoft Annotations
    #[serde(flatten)]
    pub ms_annotations: MSAnnotationsProperty,

    // SAP Annotations
    #[serde(flatten)]
    pub sap_annotations: SAPAnnotations,
}

/// ********************************************************************************************************************
/// The `Cargo.toml` of the application consuming the code generated by this tool must declare at least the following
/// dependencies:
///
/// ```toml
/// [dependencies]
/// rust_decimal = "1.29"
/// uuid = "1.3"
/// ```
///
/// Edm.Decimal --> rust_decimal::Decimal
/// Edm.Guid    --> uuid::Uuid
/// ********************************************************************************************************************
impl Property {
    fn trim_prefix<'a>(some_str: &'a str, some_prefix: &str) -> &'a str {
        match some_str.strip_prefix(some_prefix) {
            Some(suffix) => suffix,
            None => some_str,
        }
    }

    fn maybe_optional(rust_type: &str, is_optional: bool) -> String {
        if is_optional {
            format!("Option<{}>", rust_type)
        } else {
            rust_type.to_string()
        }
    }

    fn to_rust_safe_name(&self) -> String {
        CheckKeyword::into_safe(convert_case::Casing::to_case(&self.name, Case::Snake))
    }

    // For complex types, the type struct will already have been generated using the <ct_name> part extracted
    // from the OData type name conforming to one of these patterns:
    //   <namespace>.CT_<ct_name>
    //   <namespace>.<ct_name>
    //   <ct_name>
    pub fn trim_complex_type_name(type_name: &str, namespace: &str) -> String {
        let trim1 = Property::trim_prefix(type_name, &format!("{}.", namespace));
        let trim2 = Property::trim_prefix(trim1, "CT_");

        convert_case::Casing::to_case(&trim2, convert_case::Case::Pascal)
    }

    fn to_rust_type(&self, namespace: &str) -> String {
        match self.edm_type.as_ref() {
            "Edm.Binary" => Property::maybe_optional("Vec<u8>", self.nullable),
            "Edm.Boolean" => Property::maybe_optional("bool", self.nullable),
            "Edm.Byte" => "u8".to_string(),
            "Edm.DateTime" => Property::maybe_optional("NaiveDateTime", self.nullable),
            // TODO I suspect that this may not be the correct Rust datatype for Edm.DateTimeOffset...
            "Edm.DateTimeOffset" => Property::maybe_optional("NaiveDateTime", self.nullable),
            "Edm.Decimal" => "Decimal".to_string(),
            "Edm.Double" => "f64".to_string(),
            "Edm.Single" => "f32".to_string(),
            "Edm.Guid" => "uuid".to_string(),
            "Edm.SByte" => Property::maybe_optional("i8", self.nullable),
            "Edm.Int16" => Property::maybe_optional("i16", self.nullable),
            "Edm.Int32" => Property::maybe_optional("i32", self.nullable),
            "Edm.Int64" => Property::maybe_optional("i64", self.nullable),
            "Edm.String" => Property::maybe_optional("String", self.nullable),
            "Edm.Time" => Property::maybe_optional("std::time::SystemTime", self.nullable),

            type_name => Property::trim_complex_type_name(type_name, namespace),
        }
    }

    pub fn to_rust(&self, namespace: &str) -> Vec<u8> {
        format!(
            "\npub {}: {},",
            self.to_rust_safe_name(),
            self.to_rust_type(namespace)
        )
        .as_bytes()
        .to_vec()
    }
}

#[derive(Debug, Serialize, Deserialize)]
#[serde(rename_all = "PascalCase")]
pub struct PropertyRef {
    pub name: String,
}

mod tests {

    #[test]
    fn should_convert_unsafe_property_name() {
        use check_keyword::CheckKeyword;
        let kw = "type";

        assert!(kw.is_keyword());
        assert_eq!(kw.into_safe(), "r#type");
    }

    #[test]
    fn should_not_convert_safe_property_name() {
        use check_keyword::CheckKeyword;
        let kw = "wibble";

        assert!(!kw.is_keyword());
        assert_eq!(kw.into_safe(), "wibble");
    }
}
