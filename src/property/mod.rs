pub mod property_type;

use crate::ms_annotations::MSAnnotationsProperty;
use crate::sap_annotations::SAPAnnotations;
use crate::xml::default_true;
use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize, Deserialize)]
#[serde(rename_all = "PascalCase")]
pub struct Property {
    pub name: String,

    #[serde(rename = "Type")]
    pub edm_type: String,

    #[serde(default = "default_true")]
    pub nullable: bool,

    pub max_length: Option<String>,

    pub precision: Option<String>,
    pub scale: Option<String>,
    pub concurrency_mode: Option<String>,

    // Microsoft Annotations
    #[serde(flatten)]
    pub ms_annotations: MSAnnotationsProperty,

    // SAP Annotations
    #[serde(flatten)]
    pub sap_annotations: SAPAnnotations,
}

/// ********************************************************************************************************************
/// The `Cargo.toml` of the application consuming the code generated by this tool must declare at least the following
/// dependencies:
///
/// ```toml
/// [dependencies]
/// rust_decimal = "1.29"
/// uuid = "1.3"
/// ```
///
/// Edm.Decimal --> rust_decimal::Decimal
/// Edm.Guid    --> uuid::Uuid
/// ********************************************************************************************************************
impl Property {
    pub fn to_rust(prop: Property) -> String {
        match prop.edm_type.as_ref() {
            "Edm.Binary" => {
                if prop.nullable {
                    format!("{}: Option<Vec<u8>>,", prop.name)
                } else {
                    format!("{}: Vec<u8>,", prop.name)
                }
            }

            "Edm.Boolean" => {
                if prop.nullable {
                    format!("{}: Option<bool>,", prop.name)
                } else {
                    format!("{}: bool,", prop.name)
                }
            }

            "Edm.Byte" => {
                format!("{}: u8,", prop.name)
            }

            "Edm.DateTime" => {
                if prop.nullable {
                    format!("{}: Option<NaiveDateTime>,", prop.name)
                } else {
                    format!("{}: NaiveDateTime,", prop.name)
                }
            }

            "Edm.DateTimeOffset" => {
                todo!("Find correct Rust data type for Edm.DateTimeOffset")
            }

            // This declaration cannot account for the decimal precision
            // This must be provided at the time the decimal instance is created
            "Edm.Decimal" => {
                format!("{}: Decimal,", prop.name)
            }

            "Edm.Double" => {
                format!("{}: f64,", prop.name)
            }

            "Edm.Single" => {
                format!("{}: f32,", prop.name)
            }

            "Edm.Guid" => {
                format!("{}: uuid,", prop.name)
            }

            "Edm.SByte" => {
                if prop.nullable {
                    format!("{}: Option<i8>,", prop.name)
                } else {
                    format!("{}: i8,", prop.name)
                }
            }

            "Edm.Int16" => {
                if prop.nullable {
                    format!("{}: Option<i16>,", prop.name)
                } else {
                    format!("{}: i16,", prop.name)
                }
            }

            "Edm.Int32" => {
                if prop.nullable {
                    format!("{}: Option<i32>,", prop.name)
                } else {
                    format!("{}: i32,", prop.name)
                }
            }

            "Edm.Int64" => {
                if prop.nullable {
                    format!("{}: Option<i64>,", prop.name)
                } else {
                    format!("{}: i64,", prop.name)
                }
            }

            "Edm.String" => {
                if prop.nullable {
                    format!("{}: Option<String>,", prop.name)
                } else {
                    format!("{}: String,", prop.name)
                }
            }

            "Edm.Time" => {
                if prop.nullable {
                    format!("{}: Option<std::time::SystemTime>,", prop.name)
                } else {
                    format!("{}: std::time::SystemTime,", prop.name)
                }
            }

            _ => panic!(
                "Property {} has unknown property type {}",
                prop.name, prop.edm_type
            ),
        }
    }
}

#[derive(Debug, Serialize, Deserialize)]
#[serde(rename_all = "PascalCase")]
pub struct PropertyRef {
    pub name: String,
}
