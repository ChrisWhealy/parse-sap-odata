// pub mod property_type;

use check_keyword::CheckKeyword;
use convert_case::Case;
use serde::{Deserialize, Serialize};

use crate::ms_annotations::MSAnnotationsProperty;
use crate::sap_annotations::SAPAnnotations;
use crate::xml::default_true;

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// All known strings are hard-coded as u8 arrays
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
static LINE_FEED: &[u8] = &[0x0a];
static SPACE: &[u8] = &[0x20];

static BOOLEAN: &[u8] = "bool".as_bytes();
static COMMA: &[u8] = ",".as_bytes();
static COLON: &[u8] = ":".as_bytes();
static DECIMAL: &[u8] = "rust_decimal::Decimal".as_bytes();
static F32: &[u8] = "f32".as_bytes();
static F64: &[u8] = "f64".as_bytes();
static I8: &[u8] = "i8".as_bytes();
static I16: &[u8] = "i16".as_bytes();
static I32: &[u8] = "i32".as_bytes();
static I64: &[u8] = "i64".as_bytes();
static NAIVE_DATE_TIME: &[u8] = "chrono::NaiveDateTime".as_bytes();
static OPTION_DECLARATION: &[u8] = "Option<".as_bytes();
static PUBLIC: &[u8] = "pub".as_bytes();
static STD_TIME_SYSTEMTIME: &[u8] = "std::time::SystemTime".as_bytes();
static STRING: &[u8] = "String".as_bytes();
static TYPE_TERMINATOR: &[u8] = ">".as_bytes();
static UUID: &[u8] = "uuid::Uuid".as_bytes();
static U8: &[u8] = "u8".as_bytes();
static VECTOR_U8: &[u8] = "Vec<u8>".as_bytes();

#[derive(PartialEq, Eq, PartialOrd, Ord, Clone, Debug, Serialize, Deserialize)]
#[serde(rename_all = "PascalCase")]
pub struct Property {
    pub name: String,

    #[serde(rename = "Type")]
    pub edm_type: String,

    #[serde(default = "default_true")]
    pub nullable: bool,

    pub max_length: Option<u16>,

    pub precision: Option<u16>,
    pub scale: Option<u16>,
    pub concurrency_mode: Option<String>,

    // Microsoft Annotations
    #[serde(flatten)]
    pub ms_annotations: MSAnnotationsProperty,

    // SAP Annotations
    #[serde(flatten)]
    pub sap_annotations: SAPAnnotations,
}

/// ********************************************************************************************************************
/// The `Cargo.toml` of the application consuming the code generated by this tool must declare at least the following
/// dependencies:
///
/// ```toml
/// [dependencies]
/// rust_decimal = "1.29"
/// uuid = "1.3"
/// ```
///
/// Edm.Decimal --> rust_decimal::Decimal
/// Edm.Guid    --> uuid::Uuid
/// ********************************************************************************************************************
impl Property {
    fn trim_prefix<'a>(some_str: &'a str, some_prefix: &str) -> &'a str {
        if let Some(suffix) = some_str.strip_prefix(some_prefix) {
            suffix
        } else {
            some_str
        }
    }

    fn maybe_optional(rust_type: &[u8], is_optional: bool) -> Vec<u8> {
        if is_optional {
            [OPTION_DECLARATION, rust_type, TYPE_TERMINATOR].concat()
        } else {
            [rust_type].concat()
        }
    }

    fn to_rust_safe_name(&self) -> Vec<u8> {
        CheckKeyword::into_safe(convert_case::Casing::to_case(&self.name, Case::Snake))
            .as_bytes()
            .to_vec()
    }

    // For complex types, the type struct will already have been generated using the <ct_name> part extracted
    // from the OData type name conforming to one of these patterns:
    //   <namespace>.CT_<ct_name>
    //   <namespace>.<ct_name>
    //   <ct_name>
    pub fn trim_complex_type_name(type_name: &str, namespace: &str) -> Vec<u8> {
        let trimmed = Property::trim_prefix(type_name, namespace);
        let trimmed = Property::trim_prefix(trimmed, ".");
        let trimmed = Property::trim_prefix(trimmed, "CT_");

        convert_case::Casing::to_case(&trimmed, convert_case::Case::Pascal)
            .as_bytes()
            .to_vec()
    }

    fn to_rust_type(&self, namespace: &str) -> Vec<u8> {
        match self.edm_type.as_ref() {
            "Edm.Binary" => Property::maybe_optional(VECTOR_U8, self.nullable),
            "Edm.Boolean" => Property::maybe_optional(BOOLEAN, self.nullable),
            "Edm.Byte" => U8.to_vec(),
            "Edm.DateTime" => Property::maybe_optional(NAIVE_DATE_TIME, self.nullable),
            // TODO I suspect that this may not be the correct Rust datatype for Edm.DateTimeOffset...
            "Edm.DateTimeOffset" => Property::maybe_optional(NAIVE_DATE_TIME, self.nullable),
            "Edm.Decimal" => DECIMAL.to_vec(),
            "Edm.Double" => F64.to_vec(),
            "Edm.Single" => F32.to_vec(),
            "Edm.Guid" => UUID.to_vec(),
            "Edm.SByte" => Property::maybe_optional(I8, self.nullable),
            "Edm.Int16" => Property::maybe_optional(I16, self.nullable),
            "Edm.Int32" => Property::maybe_optional(I32, self.nullable),
            "Edm.Int64" => Property::maybe_optional(I64, self.nullable),
            "Edm.String" => Property::maybe_optional(STRING, self.nullable),
            "Edm.Time" => Property::maybe_optional(STD_TIME_SYSTEMTIME, self.nullable),

            type_name => Property::trim_complex_type_name(type_name, namespace),
        }
    }

    pub fn to_rust(&self, namespace: &str) -> Vec<u8> {
        [
            LINE_FEED.to_vec(),
            PUBLIC.to_vec(),
            SPACE.to_vec(),
            self.to_rust_safe_name(),
            COLON.to_vec(),
            self.to_rust_type(namespace),
            COMMA.to_vec(),
        ]
        .concat()
    }
}

#[derive(Debug, Serialize, Deserialize)]
#[serde(rename_all = "PascalCase")]
pub struct PropertyRef {
    pub name: String,
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#[cfg(test)]
pub mod unit_tests;
