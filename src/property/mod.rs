#[cfg(feature = "parser")]
use crate::{
    parser::{syntax_fragments::*, AsRustSrc},
    utils::{odata_name_to_rust_safe_name, to_pascal_case},
};

use crate::{
    sap_annotations::SAPAnnotationsProperty,
    utils::{de_str_to_bool, default_false, default_true},
};
use serde::{Deserialize, Serialize};

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
/// Represents an `edm:Property` element
#[derive(PartialEq, Eq, PartialOrd, Ord, Clone, Debug, Serialize, Deserialize)]
#[serde(rename_all = "PascalCase")]
pub struct Property {
    #[serde(rename = "@Name")]
    pub odata_name: String,

    #[serde(rename = "@Type")]
    pub edm_type: String,

    #[serde(rename = "@Nullable", default = "default_true")]
    pub nullable: bool,

    #[serde(rename = "@MaxLength")]
    pub max_length: Option<u16>,

    #[serde(rename = "@Precision")]
    pub precision: Option<u16>,

    #[serde(rename = "@Scale")]
    pub scale: Option<u16>,

    #[serde(rename = "@ConcurrencyMode")]
    pub concurrency_mode: Option<String>,

    // Microsoft Annotations
    #[serde(
        rename = "@FC_KeepInContent",
        deserialize_with = "de_str_to_bool",
        default = "default_false"
    )]
    pub fc_keep_in_content: bool,

    #[serde(rename = "@FC_TargetPath")]
    pub fc_target_path: Option<String>,

    // SAP Annotations
    #[serde(flatten)]
    pub sap_annotations: SAPAnnotationsProperty,

    #[serde(skip, default)]
    pub deserializer_fn: &'static str,

    #[serde(skip, default)]
    pub deserializer_module: &'static str,
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
/// The `Cargo.toml` of the application consuming the code generated by this tool must declare at least the following
/// dependencies:
///
/// ```toml
/// [dependencies]
/// chrono = { version = "0.4", features = ["serde"]}
/// rust_decimal = "1.30"
/// serde = { version = "1.0", features = ["derive"] }
/// uuid = { version = "1.4", features = ["serde"]}
/// ```
#[cfg(feature = "parser")]
impl Property {
    fn trim_prefix<'de>(some_str: &'de str, some_prefix: &str) -> &'de str {
        if let Some(suffix) = some_str.strip_prefix(some_prefix) {
            suffix
        } else {
            some_str
        }
    }

    fn maybe_optional(&self, rust_type: &[u8]) -> Vec<u8> {
        if self.nullable {
            gen_option_of_type(rust_type)
        } else {
            rust_type.to_vec()
        }
    }

    // For complex types, the type struct will already have been generated using the <ct_name> part extracted
    // from the OData type name conforming to one of these patterns:
    //   <namespace>.CT_<ct_name>
    //   <namespace>.<ct_name>
    //   <ct_name>
    pub fn trim_complex_type_name<'a>(type_name: &'a str, namespace: &'a str) -> Vec<u8> {
        let trimmed = Property::trim_prefix(type_name, namespace);
        let trimmed = Property::trim_prefix(trimmed, ".");
        let trimmed = Property::trim_prefix(trimmed, "CT_");

        convert_case::Casing::to_case(&trimmed, convert_case::Case::Pascal)
            .as_bytes()
            .to_vec()
    }
}

#[cfg(feature = "parser")]
impl AsRustSrc for Property {
    fn to_rust_type<'a>(&mut self, namespace: &str) -> Vec<u8> {
        // Handle complex types separately
        let type_bytes: Vec<u8> = if self.edm_type.starts_with("Edm.") {
            match self.edm_type.as_ref() {
                // EDM allows for null which is intentionally excluded by Rust
                "Edm.Null" => UNIT.to_vec(),
                "Edm.Binary" => self.maybe_optional(VECTOR_U8),
                "Edm.Boolean" => self.maybe_optional(BOOLEAN),
                "Edm.Byte" => U8.to_vec(),
                "Edm.DateTime" => {
                    if self.nullable {
                        self.deserializer_fn = SERDE_DE_DATETIME_OPT;
                        self.maybe_optional(NAIVE_DATE_TIME)
                    } else {
                        self.deserializer_fn = SERDE_DE_DATETIME;
                        NAIVE_DATE_TIME.to_vec()
                    }
                },
                "Edm.DateTimeOffset" => {
                    if self.nullable {
                        self.deserializer_fn = SERDE_DE_DATETIME_OPT;
                        self.maybe_optional(NAIVE_DATE_TIME)
                    } else {
                        self.deserializer_fn = SERDE_DE_DATETIME;
                        NAIVE_DATE_TIME.to_vec()
                    }
                },
                "Edm.Decimal" => {
                    if self.nullable {
                        self.deserializer_module = SERDE_DE_DECIMAL_OPT;
                        self.maybe_optional(DECIMAL)
                    } else {
                        self.deserializer_module = SERDE_DE_DECIMAL;
                        DECIMAL.to_vec()
                    }
                },
                "Edm.Double" => F64.to_vec(),
                "Edm.Single" => F32.to_vec(),
                "Edm.Guid" => UUID.to_vec(),
                "Edm.SByte" => self.maybe_optional(I8),
                "Edm.Int16" => self.maybe_optional(I16),
                "Edm.Int32" => self.maybe_optional(I32),
                "Edm.Int64" => self.maybe_optional(I64),
                "Edm.Time" => self.maybe_optional(STD_TIME_SYSTEMTIME),

                // Use String as the catch-all case
                _ => self.maybe_optional(STRING),
            }
        } else {
            Property::trim_complex_type_name(&self.edm_type, namespace)
        };

        type_bytes.to_vec()
    }

    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    /// Any property whose name clashes with a Rust reserved word is written in raw format:<br>
    /// E.G. `clash --> r#clash`
    fn to_rust(&mut self, namespace: &str) -> Vec<u8> {
        let mut response: Vec<u8> = Vec::new();

        // Check whether the Pascal case name is correctly transformed into a Pascal case name.
        // If not, output a serde_rename attribute.
        //
        // This catches deserialization problems with fields that contain capitalised abbreviations:
        // E.G. SAP tends not to format abbreviations such as "ID" into correct PascalCase.  Consequently, instead of
        // seeing the correct value "BusinessPartnerId" , you will see "BusinessPartnerID"
        //                         Correct character ^              Incorrect character ^
        if !to_pascal_case(&self.odata_name).eq(&self.odata_name) {
            response.extend(gen_serde_rename(&self.odata_name))
        }

        let rust_safe_name = odata_name_to_rust_safe_name(&self.odata_name);
        let rust_type = &self.to_rust_type(namespace);

        // Add attribute pointing either to a custom deserializer function or a deserializer module.
        // Only one of these deserializers should ever be populated at any one time!
        if !self.deserializer_fn.is_empty() {
            response.extend(deserialize_with(self.deserializer_fn, true))
        }
        if !self.deserializer_module.is_empty() {
            response.extend(deserialize_with(self.deserializer_module, false))
        }

        // Write struct field
        response.extend(gen_struct_field(&rust_safe_name, rust_type));

        response
    }
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
/// Represents a `<PropertyRef>` tag
#[derive(Debug, Serialize, Deserialize)]
#[serde(rename_all = "PascalCase")]
pub struct PropertyRef {
    #[serde(rename = "@Name")]
    pub name: String,
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#[cfg(test)]
pub mod unit_tests;
