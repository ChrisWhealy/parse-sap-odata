use std::collections::VecDeque;
use std::fmt::Formatter;

use crate::{
    edmx::data_services::schema::association::Association,
    parser::syntax_fragments::{
        fragment_generators::gen_owned_string, CLOSE_PAREN, CLOSE_SQR, COLON, COMMA, END_BLOCK, LINE_FEED, NONE,
        OPEN_CURLY, OPEN_PAREN, OPEN_SQR, SOME,
    },
};

static MY_NAME: &[u8] = "Association".as_bytes();
static UNDERSCORE: &str = "_";

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// Association[Set] names generated by SAP are always in the form "Assoc_<from_entity>_<to_entity>[_AssocSet]" up to a
// maximum length of 40 characters.  Names longer than 40 characters are simply truncated.

// Split an Association or AssociationSet name into its constituent parts and discard the "Assoc" prefix and as much of
// the "AssocSet" suffix as might be present.
pub fn normalise_assoc_name(assoc_name: &str) -> String {
    let mut assoc_name_parts = assoc_name.split(UNDERSCORE).collect::<VecDeque<&str>>();

    // Maybe remove the first element
    if assoc_name_parts[0].eq("Assoc") {
        let _ = assoc_name_parts.pop_front();
    };

    if "AssocSet".starts_with(assoc_name_parts[assoc_name_parts.len() - 1]) {
        let _ = assoc_name_parts.pop_back();
    };

    // Rebuild Association name using underscore as the separator
    assoc_name_parts.iter().enumerate().map(
        |(idx, name_part)|
        format!("{}{}", if idx == 0 { "" } else { UNDERSCORE }, name_part)
    ).collect::<String>()
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
pub enum AssociationMetadata {
    Name,
    SapContentVersion,
    Ends,
    ReferentialConstraint,
}

impl AssociationMetadata {
    pub fn get_field_name(prop_name: AssociationMetadata) -> Vec<u8> {
        let member = match prop_name {
            AssociationMetadata::Name => "name",
            AssociationMetadata::SapContentVersion => "sap_content_version",
            AssociationMetadata::Ends => "ends",
            AssociationMetadata::ReferentialConstraint => "referential_constraint",
        };

        member.as_bytes().to_vec()
    }
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
fn line_from_association(prop_md: AssociationMetadata, val: Vec<u8>) -> Vec<u8> {
    [&*AssociationMetadata::get_field_name(prop_md), COLON, &val, COMMA, LINE_FEED].concat()
}

impl std::fmt::Display for Association {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        let ends = [
            OPEN_SQR,
            format!("{}", self.ends[0]).as_bytes(),
            COMMA,
            format!("{}", self.ends[1]).as_bytes(),
            CLOSE_SQR,
        ]
        .concat();
        let ref_con = if let Some(ref_con) = &self.referential_constraint {
            [SOME, OPEN_PAREN, format!("{}", ref_con).as_bytes(), CLOSE_PAREN].concat()
        } else {
            NONE.to_vec()
        };

        let out_buffer: Vec<u8> = [
            MY_NAME,
            OPEN_CURLY,
            &*line_from_association(AssociationMetadata::Name, gen_owned_string(&self.name)),
            &*line_from_association(
                AssociationMetadata::SapContentVersion,
                gen_owned_string(&self.sap_content_version),
            ),
            &*line_from_association(AssociationMetadata::Ends, ends),
            &*line_from_association(AssociationMetadata::ReferentialConstraint, ref_con),
            END_BLOCK,
        ]
        .concat();

        write!(f, "{}", String::from_utf8(out_buffer).unwrap())
    }
}
